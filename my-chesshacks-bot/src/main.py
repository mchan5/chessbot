# main.py
from .utils import chess_manager, GameContext
from chess import Move
import chess
import chess.pgn
import random
import io
import torch
from transformers import AutoModelForCausalLM, AutoTokenizer

# ----------------------------
# Load Hugging Face model
# ----------------------------
MODEL_NAME = "lazy-guy12/chess-llama"  # your model
CACHE_DIR = "./.model_cache"

tokenizer = AutoTokenizer.from_pretrained(MODEL_NAME, cache_dir=CACHE_DIR)
model = AutoModelForCausalLM.from_pretrained(MODEL_NAME, cache_dir=CACHE_DIR)
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model.to(device)
model.eval()


# ----------------------------
# Convert PGN to board
# ----------------------------
def pgn_to_board(pgn: str) -> chess.Board:
    game = chess.pgn.read_game(io.StringIO(pgn))
    if game is None:
        raise ValueError("Invalid PGN")
    board = game.board()
    for move in game.mainline_moves():
        board.push(move)
    return board


# ----------------------------
# Get move from model
# ----------------------------
def get_move(pgn: str) -> str:
    board = pgn_to_board(pgn)

    # Convert move history to UCI string for model input
    move_history = " ".join([m.uci() for m in board.move_stack])
    inputs = tokenizer(move_history, return_tensors="pt")
    for k in inputs:
        inputs[k] = inputs[k].to(device)

    # Generate predicted move(s)
    with torch.no_grad():
        outputs = model.generate(**inputs, do_sample=True, top_k=50, num_return_sequences=1)

    # Decode generated text
    generated_text = tokenizer.decode(outputs[0], skip_special_tokens=True)
    uci_moves = generated_text.strip().split()
    predicted_uci = uci_moves[-1] if uci_moves else None

    # Ensure move is legal
    legal_moves = list(board.legal_moves)
    if predicted_uci:
        try:
            move_obj = chess.Move.from_uci(predicted_uci)
            if move_obj in legal_moves:
                return move_obj.uci()
        except ValueError:
            pass

    # Fallback to random legal move
    return random.choice(legal_moves).uci()


# ----------------------------
# ChessHacks entrypoint
# ----------------------------
@chess_manager.entrypoint
def bot(ctx: GameContext):
    print("Cooking move...")
    print(ctx.board.move_stack)

    legal_moves = list(ctx.board.generate_legal_moves())
    if not legal_moves:
        ctx.logProbabilities({})
        raise ValueError("No legal moves available")

    # Build PGN history
    exporter = chess.pgn.StringExporter(headers=False, variations=False, comments=False)
    game = chess.pgn.Game.from_board(ctx.board)
    pgn_history = game.accept(exporter)

    # Generate move (fallback to random if model fails)
    try:
        move_uci = get_move(pgn_history)
        move_obj = Move.from_uci(move_uci)
        if move_obj not in legal_moves:
            raise ValueError("Illegal move generated by model")
    except Exception:
        move_obj = random.choice(legal_moves)

    # Log uniform probabilities for devtools
    move_probs = {m: 1 / len(legal_moves) for m in legal_moves}
    ctx.logProbabilities(move_probs)

    return move_obj


@chess_manager.reset
def reset(ctx: GameContext):
    # Reset any model state if needed
    pass


# from .utils import chess_manager, GameContext
# from chess import Move
# import random
# import time

# # Write code here that runs once
# # Can do things like load models from huggingface, make connections to subprocesses, etcwenis

# from transformers import AutoModel
# import os

# # Load model from Hugging Face
# model = AutoModel.from_pretrained(
#     "lazy-guy12/chess-llama",
#     cache_dir="./.model_cache"  # Cache locally
# )

# print('Done loading')

# def get_move(pgn: str) -> str:
#     # Use your model for inference
#     # ...
#     pass

# @chess_manager.entrypoint
# def test_func(ctx: GameContext):
#     # This gets called every time the model needs to make a move
#     # Return a python-chess Move object that is a legal move for the current position

#     print("Cooking move...")
#     print(ctx.board.move_stack)
#     time.sleep(0.1)

#     legal_moves = list(ctx.board.generate_legal_moves())
#     if not legal_moves:
#         ctx.logProbabilities({})
#         raise ValueError("No legal moves available (i probably lost didn't i)")

#     move_weights = [random.random() for _ in legal_moves]
#     total_weight = sum(move_weights)
#     # Normalize so probabilities sum to 1
#     move_probs = {
#         move: weight / total_weight
#         for move, weight in zip(legal_moves, move_weights)
#     }
#     ctx.logProbabilities(move_probs)

#     return random.choices(legal_moves, weights=move_weights, k=1)[0]


# @chess_manager.reset
# def reset_func(ctx: GameContext):
#     # This gets called when a new game begins
#     # Should do things like clear caches, reset model state, etc.
#     pass
